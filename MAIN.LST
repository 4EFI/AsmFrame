Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 1
main.asm



      1
      2				     .186
      3	0000			     .model tiny
      4	0000			     .code
      5				     org 100h
      6
      7				     locals __
      8
      9				     include	     TOOLS.ASM					     ; Exit
1    10
1    11				     ;------------------------------------------------
1    12				     ;	     EXIT PROGRAM
1    13				     ;------------------------------------------------
1    14				     ; Entry:	     NONE
1    15				     ; EXIT:	     NONE
1    16				     ; DESTROYS: AX
1    17				     ;------------------------------------------------
1    18
1    19				     EXIT	     macro
1    20							     nop
1    21							     mov ax, 4c00h
1    22							     int 21h
1    23							     nop
1    24							     endm
1    25
1    26				     ;------------------------------------------------
     27
     28				     ;------------------------------------------------
     29
     30	0100  BB B800		     Start:	     mov bx, 0b800h			     ; ES = VideoSeg
     31	0103  8E C3					     mov es, bx
     32
     33	0105  B1 00					     mov cl, 0					     ; Cmd line	box handler
     34	0107  B5 06					     mov ch, 6
     35	0109  BB 0139r					     mov bx, offset CmdData
     36	010C  E8 032A					     call CmdLineHndl
     37
     38	010F  80 3E 013Er 00				     cmp CmdData[Type_Num], 0	     ; if( Type	!= 0 )
     39	0114  75 0A					     jne     __NotUserType
     40
     41	0116  8A C8					     mov cl, al					     ; User's box handler
     42	0118  B5 09					     mov ch, 9
     43	011A  BB 0246r					     mov bx, offset Type_0
     44	011D  E8 0319					     call CmdLineHndl
     45
     46	0120						     __NotUserType:
     47
     48	0120  50					     push ax
     49	0121  B8 0020					     mov  ax, '	'
     50	0124  E8 0054					     call ClrScreen
     51	0127  58					     pop  ax
     52
     53	0128  B8 04D2					     mov ax, 1234d
     54	012B  B7 00					     mov bh, 0d
     55	012D  B3 0F					     mov bl, 15d
     56	012F  E8 0539					     call PrintNum
     57
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 2
main.asm



     58							     ; add ax, 83h
     59							     ; mov bx, offset CmdData
     60							     ; call PrintBox
     61
     62							     EXIT
1    63	0132  90					     nop
1    64	0133  B8 4C00					     mov ax, 4c00h
1    65	0136  CD 21					     int 21h
1    66	0138  90					     nop
     67
     68				     ;------------------------------------------------
     69
     70	0139  14*(00)		     CmdData db	     20	dup (0)		     ; Cmd line	data
     71
     72				     include	     SCR_HNDL.ASM    ; Clear screen function
1    73
1    74				     ; SCREEN HANDLER
1    75
1    76				     ;------------------------------------------------
1    77				     ;	     FILL SCREEN BY SYM
1    78				     ;	     FROM ( X; Y ) to (	X + WIDTH; Y + HEIGHT )
1    79				     ;------------------------------------------------
1    80				     ; ENTRY:	     AH	= COLOR	ATTR
1    81				     ;			     AL	= SYM
1    82				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1    83				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1    84				     ;			     CH	= WIDTH
1    85				     ;			     CL	= HEIGHT
1    86				     ; EXIT:	     NONE
1    87				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1    88				     ; DESTROYS:     NONE
1    89				     ;------------------------------------------------
1    90
1    91	014D			     FillScreen		     proc
1    92
1    93	014D  53						     push bx			     ; push (1)
1    94	014E  51						     push cx			     ; push (2)
1    95	014F  52						     push dx			     ; push (3)
1    96
1    97	0150  50						     push ax			     ; push (4)
1    98	0151  E8 0035						     call GetVideoPos
1    99	0154  8B D8						     mov bx, ax
1   100	0156  58						     pop ax			     ; pop  (4)
1   101
1   102	0157  8A F5						     __NextLine:		     mov dh, ch		     ; i =  +
    103				     CH
1   104
1   105	0159  53											     push bx		    +
    106				     ; push (5)
1   107
1   108	015A  26: 89 07											     __Next:		    +
    109				     mov es:[bx], ax
1   110	015D  83 C3 02														    +
    111				     add bx, 2
1   112
1   113	0160  FE CE														    +
    114				     dec dh		     ; i--
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 3
main.asm



1   115
1   116	0162  80 FE 00														    +
    117				     cmp dh, 0d		     ; if( dh == 0 )
1   118	0165  74 02														    +
    119				     je	__End
1   120
1   121	0167  EB F1														    +
    122				     jmp __Next
1   123	0169												     __End:
1   124
1   125	0169  5B											     pop bx		    +
    126				     ; pop  (5)
1   127
1   128	016A  81 C3 00A0										     add bx, 160d    ; BX +=+
    129				     2*80
1   130
1   131	016E  FE C9											     dec cl		    +
    132				     ; CL--
1   133
1   134	0170  80 F9 00											     cmp cl, 0d	     ; if(  +
    135				     CL	== 0 )
1   136	0173  74 02											     je	__EndNextLine
1   137
1   138	0175  EB E0											     jmp __NextLine
1   139	0177							     __EndNextLine:
1   140
1   141	0177  5A						     pop dx			     ; pop  (3)
1   142	0178  59						     pop cx			     ; pop  (2)
1   143	0179  5B						     pop bx			     ; pop  (1)
1   144
1   145	017A  C3						     ret
1   146	017B							     endp
1   147
1   148				     ;------------------------------------------------
1   149				     ;	     CLEAR SCREEN BY SYM
1   150				     ;------------------------------------------------
1   151				     ; ENTRY:	     AH	= COLOR	ATTR
1   152				     ;			     AL	= SYM
1   153				     ; EXIT:	     NONE
1   154				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   155				     ; DESTROYS:     NONE
1   156				     ;------------------------------------------------
1   157
1   158	017B			     ClrScreen		     proc
1   159
1   160	017B  53						     push bx			     ; push (1)
1   161	017C  51						     push cx			     ; push (2)
1   162
1   163	017D  33 DB						     xor bx, bx			     ; X = 0; Y	= 0
1   164	017F  B5 50						     mov ch, 80d
1   165	0181  B1 19						     mov cl, 25d
1   166	0183  E8 FFC7						     call FillScreen
1   167
1   168	0186  59						     pop cx			     ; pop  (2)
1   169	0187  5B						     pop bx			     ; pop  (1)
1   170
1   171	0188  C3						     ret
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 4
main.asm



1   172	0189							     endp
1   173
1   174				     ;------------------------------------------------
1   175				     ;	     GET VIDEO POS FROM	(X; Y)
1   176				     ;------------------------------------------------
1   177				     ; ENTRY:	     BH	= X LEFT CORNER	COORDS [0; 79]
1   178				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   179				     ; EXIT:	     AX	= POS
1   180				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   181				     ; DESTROYS:     AX
1   182				     ;------------------------------------------------
1   183
1   184	0189			     GetVideoPos	     proc
1   185
1   186	0189  D0 E7						     shl bh, 1		     ; bh /= 2
1   187
1   188	018B  52						     push dx		     ; push (1)
1   189
1   190	018C  B0 A0						     mov al, 160d    ; ax = 160	* Y + 2	* X
1   191	018E  F6 E3						     mul bl
1   192	0190  BA 0000						     mov dx, 0
1   193	0193  02 D7						     add dl, bh
1   194	0195  03 C2						     add ax, dx
1   195
1   196	0197  5A						     pop dx		     ; pop  (1)
1   197
1   198	0198  D0 EF						     shr bh, 1		     ; bh *= 2
1   199
1   200	019A  C3						     ret
1   201	019B							     endp
1   202
1   203				     ;------------------------------------------------
1   204				     ;	     PRINT SYM IN (X; Y)
1   205				     ;------------------------------------------------
1   206				     ; ENTRY:	     AH	= SYM COLOR
1   207				     ;			     AL	= SYM CHAR
1   208				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1   209				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   210				     ; EXIT:	     NONE
1   211				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   212				     ; DESTROYS:     NONE
1   213				     ;------------------------------------------------
1   214
1   215	019B			     PrintChar		     proc
1   216
1   217	019B  57						     push di		     ; push (1)
1   218	019C  50						     push ax		     ; push (2)
1   219
1   220	019D  E8 FFE9						     call GetVideoPos
1   221
1   222	01A0  8B F8						     mov di, ax		     ; print( ax )
1   223	01A2  58						     pop ax		     ; pop  (2)
1   224	01A3  AB						     stosw
1   225
1   226	01A4  5F						     pop di		     ; pop  (1)
1   227
1   228	01A5  C3						     ret
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 5
main.asm



1   229	01A6							     endp
1   230
1   231				     ;------------------------------------------------
1   232				     ;	     PRINT STR IN (X; Y)
1   233				     ;------------------------------------------------
1   234				     ; ENTRY:	     AH	= SYM COLOR
1   235				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1   236				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   237				     ;			     CX	= STR ADDR
1   238				     ; EXIT:	     NONE
1   239				     ; EXPECTS:	     ES	     = 0b800h (VIDEO SEGMENT)
1   240				     ;			     END SYM = '\0' || '$' || '\r'
1   241				     ; DESTROYS:     NONE
1   242				     ;------------------------------------------------
1   243
1   244	01A6			     PrintStr		     proc
1   245
1   246	01A6  50						     push ax		     ; push (1)
1   247	01A7  53						     push bx		     ; push (2)
1   248	01A8  52						     push dx		     ; push (3)
1   249	01A9  56						     push si		     ; push (4)
1   250
1   251	01AA  8B F1						     mov si, cx		     ; SI = StrAddr
1   252
1   253	01AC  8A 14						     __Next:		     mov dl, [si]    ; DX = CurrSym
1   254
1   255	01AE  80 FA 00										     cmp dl, 0d		     ; if(  +
    256				     DL	== 0 )
1   257	01B1  74 14										     je	__End
1   258	01B3  80 FA 0D										     cmp dl, 13d	     ; if(  +
    259				     DL	== '\r'	)
1   260	01B6  74 0F										     je	__End
1   261	01B8  80 FA 24										     cmp dl, '$'	     ; if(  +
    262				     DL	== '$' )
1   263	01BB  74 0A										     je	__End
1   264
1   265	01BD  8A 04										     mov al, [si]    ; AL = CurrSym
1   266	01BF  E8 FFD9										     call PrintChar
1   267
1   268	01C2  FE C7										     inc bh		     ; X++
1   269	01C4  46										     inc si		     ;	    +
    270				     CurrSymPos++
1   271
1   272	01C5  E2 E5										     loop __Next
1   273	01C7							     __End:
1   274
1   275	01C7  5E						     pop si		     ; pop  (4)
1   276	01C8  5A						     pop dx		     ; pop  (3)
1   277	01C9  58						     pop ax		     ; pop  (2)
1   278	01CA  5B						     pop bx		     ; pop  (1)
1   279
1   280	01CB  C3						     ret
1   281	01CC							     endp
1   282
1   283				     ;------------------------------------------------
1   284				     ;	     PRINT HORIZONTAL LINE IN (X; Y)
1   285				     ;------------------------------------------------
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 6
main.asm



1   286				     ; ENTRY:	     AH	= SYM COLOR
1   287				     ;			     AL	= SYM CHAR
1   288				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1   289				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   290				     ;			     CH	= WIDTH
1   291				     ;			     DH	= LEFT	SYM
1   292				     ;			     DL	= RIGHT	SYM
1   293				     ; EXIT:	     NONE
1   294				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   295				     ; DESTROYS:     NONE
1   296				     ;------------------------------------------------
1   297
1   298	01CC			     PrintHrzLine    proc
1   299
1   300	01CC  80 FD 01						     cmp ch, 1			     ; if( ch <= 1 ) ret
1   301	01CF  76 37						     jbe __End
1   302
1   303	01D1  53						     push bx			     ; push (1)
1   304	01D2  52						     push dx			     ; push (2)
1   305
1   306
1   307	01D3  50						     push ax			     ; push (3)
1   308	01D4  8A C6						     mov al, dh			     ; printf( "%c", LeftSym )
1   309	01D6  E8 FFC2						     call PrintChar
1   310	01D9  58						     pop ax			     ; pop  (3)
1   311
1   312	01DA  50						     push ax			     ; push (4)
1   313	01DB  53						     push bx			     ; push (5)
1   314	01DC  02 FD						     add bh, ch			     ; X += ( WIDTH - 1	)
1   315	01DE  80 EF 01						     sub bh, 1
1   316	01E1  8A C2						     mov al, dl			     ; printf( "%c", RightSym )
1   317	01E3  E8 FFB5						     call PrintChar
1   318	01E6  5B						     pop bx			     ; pop  (5)
1   319	01E7  58						     pop ax			     ; pop  (4)
1   320
1   321	01E8  53						     push bx			     ; push (6)
1   322	01E9  51						     push cx			     ; push (7)
1   323
1   324	01EA  80 C7 01						     add bh, 1			     ; X += 1
1   325	01ED  80 ED 02						     sub ch, 2			     ; WIDTH -=	2
1   326
1   327	01F0  80 FD 00						     cmp ch, 0			     ; if( ch == 0 )
1   328	01F3  74 0F						     je	     __EndPrinting
1   329
1   330	01F5  33 D2						     xor dx, dx			     ; i = 0
1   331
1   332	01F7  E8 FFA1						     __Next:		     call PrintChar
1   333
1   334	01FA  FE C7										     inc bh
1   335	01FC  FE C6										     inc dh
1   336
1   337	01FE  3A F5										     cmp dh, ch
1   338	0200  74 02										     je	 __EndPrinting
1   339
1   340	0202  EB F3										     jmp __Next
1   341
1   342	0204							     __EndPrinting:
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 7
main.asm



1   343
1   344	0204  59						     pop cx			     ; pop  (7)
1   345	0205  5B						     pop bx			     ; pop  (6)
1   346
1   347
1   348	0206  5A						     pop dx			     ; pop  (2)
1   349	0207  5B						     pop bx			     ; pop  (1)
1   350
1   351	0208							     __End:
1   352	0208  C3						     ret
1   353	0209							     endp
1   354
1   355				     ;------------------------------------------------
1   356				     ;	     PRINT VERTICAL LINE IN (X;	Y)
1   357				     ;------------------------------------------------
1   358				     ; ENTRY:	     AH	= SYM COLOR
1   359				     ;			     AL	= SYM CHAR
1   360				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1   361				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   362				     ;			     CL	= HEIGHT
1   363				     ;			     DH	= TOP  SYM
1   364				     ;			     DL	= DOWN SYM
1   365				     ; EXIT:	     NONE
1   366				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   367				     ; DESTROYS:     NONE
1   368				     ;------------------------------------------------
1   369
1   370	0209			     PrintVrtLine    proc
1   371
1   372	0209  80 F9 01						     cmp cl, 1			     ; if( cl <= 1 ) ret
1   373	020C  76 37						     jbe __End
1   374
1   375	020E  53						     push bx			     ; push (1)
1   376	020F  52						     push dx			     ; push (2)
1   377
1   378
1   379	0210  50						     push ax			     ; push (3)
1   380	0211  8A C6						     mov al, dh			     ; printf( "%c", TopSym )
1   381	0213  E8 FF85						     call PrintChar
1   382	0216  58						     pop ax			     ; pop  (3)
1   383
1   384	0217  50						     push ax			     ; push (4)
1   385	0218  53						     push bx			     ; push (5)
1   386	0219  02 D9						     add bl, cl			     ; Y += ( HEIGHT - 1 )
1   387	021B  80 EB 01						     sub bl, 1
1   388	021E  8A C2						     mov al, dl			     ; printf( "%c", DownSym )
1   389	0220  E8 FF78						     call PrintChar
1   390	0223  5B						     pop bx			     ; pop  (5)
1   391	0224  58						     pop ax			     ; pop  (4)
1   392
1   393	0225  53						     push bx			     ; push (6)
1   394	0226  51						     push cx			     ; push (7)
1   395
1   396	0227  80 C3 01						     add bl, 1			     ; Y += 1
1   397	022A  80 E9 02						     sub cl, 2			     ; HEIGHT -= 2
1   398
1   399	022D  80 F9 00						     cmp cl, 0			     ; if( cl == 0 )
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 8
main.asm



1   400	0230  74 0F						     je	     __EndPrinting
1   401
1   402	0232  33 D2						     xor dx, dx			     ; i = 0
1   403
1   404	0234  E8 FF64						     __Next:		     call PrintChar
1   405
1   406	0237  FE C3										     inc bl
1   407	0239  FE C2										     inc dl
1   408
1   409	023B  3A D1										     cmp dl, cl
1   410	023D  74 02										     je	 __EndPrinting
1   411
1   412	023F  EB F3										     jmp __Next
1   413
1   414	0241							     __EndPrinting:
1   415
1   416	0241  59						     pop cx			     ; pop  (7)
1   417	0242  5B						     pop bx			     ; pop  (6)
1   418
1   419
1   420	0243  5A						     pop dx			     ; pop  (2)
1   421	0244  5B						     pop bx			     ; pop  (1)
1   422
1   423	0245							     __End:
1   424	0245  C3						     ret
1   425	0246							     endp
1   426
1   427				     ;------------------------------------------------
1   428				     ;	     PRINT BOX
1   429				     ;------------------------------------------------
1   430				     ; ENTRY:	     AX	= STR  ADDR
1   431				     ;			     BX	= DATA ADDR
1   432				     ; EXIT:	     NONE
1   433				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   434				     ; DESTROYS:     NONE
1   435				     ;------------------------------------------------
1   436
1   437				     ; User's type
1   438	0246  09*(00)		     Type_0  db		     9 dup (0)
1   439
1   440				     ; Template	types
1   441				     ;				     0		     1		     2		     3		    +
    442				     4		     5		     6		     7		     9
1   443				     ;				     lt		     ld		     rt		     rd		    +
    444				     lv		     rv		     th		     dh		     fill
1   445	024F  C9 C8 BB BC BA BA	CD+  Type_1  db		     0c9h,   0c8h,   0bbh,   0bch,   0bah,   0bah,   0cdh,   0cdh,   0d
    446	      CD 00
1   447	0258  03 03 03 03 03 03	03+  Type_2  db		     003h,   003h,   003h,   003h,   003h,   003h,   003h,   003h,   '-'
    448	      03 2D
1   449	0261  BC BB C8 C9 CD CD	BA+  Type_3  db		     0bch,   0bbh,   0c8h,   0c9h,   0cdh,   0cdh,   0bah,   0bah,   0d
    450	      BA 00
1   451	026A  DA C0 BF D9 B3 B3	C4+  Type_4  db		     0dah,   0c0h,   0bfh,   0d9h,   0b3h,   0b3h,   0c4h,   0c4h,   0d
    452	      C4 00
1   453
1   454	      =0000		     X_Num    =	0
1   455	      =0001		     Y_Num    =	1
1   456	      =0002		     W_Num    =	2
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 9
main.asm



1   457	      =0003		     H_Num    =	3
1   458	      =0004		     Clr_Num  =	4
1   459	      =0005		     Type_Num =	5
1   460
1   461	0273			     PrintBox		     proc
1   462
1   463	0273  50						     push ax				     ; push (1)
1   464	0274  53						     push bx				     ; push (2)
1   465	0275  51						     push cx				     ; push (3)
1   466	0276  52						     push dx				     ; push (4)
1   467	0277  56						     push si				     ; push (5)
1   468	0278  57						     push di				     ; push (6)
1   469	0279  55						     push bp				     ; push (7)
1   470
1   471	027A  50						     push ax				     ; push (8)	<> push	STR +
    472				     ADDR
1   473
1   474	027B  8B F3						     mov si, bx				     ; SI = DATA ADDR( BX )
1   475
1   476								     ; SET TYPE	BOX
1   477
1   478	027D  33 C0						     xor ax, ax				     ; BP = Type_0 + Type * 9
1   479	027F  8A 47 05						     mov al, bx[Type_Num]
1   480	0282  B9 0009						     mov cx, 9d
1   481	0285  F7 E1						     mul cx
1   482	0287  8B E8						     mov bp, ax
1   483	0289  81 C5 0246r					     add bp, offset Type_0
1   484
1   485	028D  8A 67 04						     mov ah, bx[Clr_Num]	     ; AH = Color
1   486
1   487	0290  8A 6F 02						     mov ch, bx[W_Num]		     ; CH = WIDTH
1   488	0293  8A 4F 03						     mov cl, bx[H_Num]		     ; CL = HEIGHT
1   489
1   490								     ; PRINT TOP HORIZONTAL LINE
1   491
1   492	0296  8A 3C						     mov  bh, si[X_Num]		     ; BH = X
1   493	0298  8A 5C 01						     mov  bl, si[Y_Num]		     ; BL = Y
1   494	029B  8A 46 06						     mov  al, bp[6]		     ; AL = horizontal sym
1   495	029E  8A 76 00						     mov  dh, bp[0]		     ; DH = left  top  sym
1   496	02A1  8A 56 02						     mov  dl, bp[2]		     ; DL = right top  sym
1   497	02A4  E8 FF25						     call PrintHrzLine
1   498
1   499								     ; PRINT LEFT VERTICAL LINE
1   500
1   501	02A7  8A 3C						     mov  bh, si[X_Num]		     ; BH = X
1   502	02A9  8A 5C 01						     mov  bl, si[Y_Num]		     ; BL = Y
1   503	02AC  8A 46 04						     mov  al, bp[4]		     ; AL = vertical  sym
1   504	02AF  8A 76 00						     mov  dh, bp[0]		     ; DH = left top  sym
1   505	02B2  8A 56 01						     mov  dl, bp[1]		     ; DL = left down sym
1   506	02B5  E8 FF51						     call PrintVrtLine
1   507
1   508	02B8  53						     push bx				     ; push (9)	<> push	(X; +
    509				     Y)
1   510
1   511								     ; PRINT DOWN HORIZONTAL LINE
1   512
1   513	02B9  8A 3C						     mov  bh, si[X_Num]		     ; BH = X
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 10
main.asm



1   514	02BB  8A 54 01						     mov  dl, si[Y_Num]		 ; Y +=	( HEIGHT - 1 )
1   515	02BE  02 D1						     add  dl, cl
1   516	02C0  80 EA 01						     sub  dl, 1
1   517	02C3  8A DA						     mov  bl, dl			     ; BL = Y
1   518	02C5  8A 46 07						     mov  al, bp[7]		     ; AL = horizontal sym
1   519	02C8  8A 76 01						     mov  dh, bp[1]		     ; DH = left  down sym
1   520	02CB  8A 56 03						     mov  dl, bp[3]		     ; DL = right down sym
1   521	02CE  E8 FEFB						     call PrintHrzLine
1   522
1   523								     ; PRINT RIGHT VERTICAL LINE
1   524
1   525	02D1  8A 14						     mov  dl, si[X_Num]		 ; X +=	( WIDTH	- 1 )
1   526	02D3  02 D5						     add  dl, ch
1   527	02D5  80 EA 01						     sub  dl, 1
1   528	02D8  8A FA						     mov  bh, dl			     ; BH = X
1   529	02DA  8A 5C 01						     mov  bl, si[Y_Num]		     ; BL = Y
1   530	02DD  8A 46 05						     mov  al, bp[5]		     ; AL = vertical   sym
1   531	02E0  8A 76 02						     mov  dh, bp[2]		     ; DH = right top  sym
1   532	02E3  8A 56 03						     mov  dl, bp[3]		     ; DL = right down sym
1   533	02E6  E8 FF20						     call PrintVrtLine
1   534
1   535								     ; FILL BOX
1   536
1   537	02E9  53						     push bx				     ; push (10)
1   538	02EA  51						     push cx				     ; push (11)
1   539	02EB  8A 3C						     mov  bh, si[X_Num]		     ; BH = X +	1
1   540	02ED  80 C7 01						     add  bh, 1
1   541	02F0  8A 5C 01						     mov  bl, si[Y_Num]		     ; BL = Y +	1
1   542	02F3  80 C3 01						     add  bl, 1
1   543	02F6  8A 46 08						     mov  al, bp[8]		     ; AL = filling sym
1   544	02F9  80 ED 02						     sub  ch, 2				     ; WIDTH  -= 2
1   545	02FC  80 E9 02						     sub  cl, 2				     ; HEIGHT -= 2
1   546	02FF  E8 FE4B						     call FillScreen
1   547	0302  59						     pop  cx				     ; pop  (11)
1   548	0303  5B						     pop  bx				     ; pop  (10)
1   549
1   550	0304  5B						     pop  bx				     ; pop  (9)	<> pop (X; Y)
1   551	0305  58						     pop  ax				     ; pop  (8)	<> pop STR  +
    552				     ADDR
1   553
1   554								     ; PRINT STR
1   555
1   556	0306  8B C8						     mov  cx, ax			     ; CX = STR	ADDR
1   557	0308  8B D8						     mov  bx, ax			     ; BX = STR	ADDR
1   558	030A  E8 018C						     call StrLen			     ; AX = len	of str
1   559	030D  F7 D8						     neg  ax				     ; AX = ( WIDTH - LEN ) +
    560				     / 2
1   561	030F  33 D2						     xor  dx, dx
1   562	0311  8A 54 02						     mov  dl, si[W_Num]
1   563	0314  03 C2						     add  ax, dx
1   564	0316  33 D2						     xor  dx, dx
1   565	0318  BD 0002						     mov  bp, 2d
1   566	031B  F7 F5						     div  bp
1   567	031D  8A 3C						     mov  bh, si[X_Num]		     ; X += AL
1   568	031F  02 F8						     add  bh, al
1   569	0321  33 C0						     xor  ax, ax			     ; AX = HEIGHT / 2
1   570	0323  8A 44 03						     mov  al, si[H_Num]
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 11
main.asm



1   571	0326  33 D2						     xor  dx, dx
1   572	0328  BD 0002						     mov  bp, 2d
1   573	032B  F7 F5						     div  bp
1   574	032D  8A 5C 01						     mov  bl, si[Y_Num]		     ; Y += AL
1   575	0330  02 D8						     add  bl, al
1   576	0332  8A 64 04						     mov  ah, si[Clr_Num]    ; AH = color
1   577	0335  E8 FE6E						     call PrintStr
1   578
1   579	0338  5D						     pop bp				     ; pop  (7)
1   580	0339  5F						     pop di				     ; pop  (6)
1   581	033A  5E						     pop si				     ; pop  (5)
1   582	033B  5A						     pop dx				     ; pop  (4)
1   583	033C  59						     pop cx				     ; pop  (3)
1   584	033D  5B						     pop bx				     ; pop  (2)
1   585	033E  58						     pop ax				     ; pop  (1)
1   586
1   587	033F  C3						     ret
1   588	0340							     endp
1   589
1   590				     ;------------------------------------------------
1   591				     ;	     ANIMATE BOX
1   592				     ;------------------------------------------------
1   593				     ; ENTRY:	     AX	= STR  ADDR
1   594				     ;			     BX	= DATA ADDR
1   595				     ; EXIT:	     NONE
1   596				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   597				     ; DESTROYS:     NONE
1   598				     ;------------------------------------------------
1   599
1   600	0340  00		     EmptyStr db	     0
1   601	0341  14*(00)		     BoxData  db     20	dup (0)
1   602
1   603	0355			     AnimBox		     proc
1   604
1   605	0355  53						     push bx		     ; push (1)
1   606	0356  51						     push cx		     ; push (2)
1   607	0357  52						     push dx		     ; push (3)
1   608
1   609	0358  8B CB						     mov  cx, bx
1   610	035A  BB 0341r						     mov  bx, offset BoxData
1   611	035D  BA 0014						     mov  dx, 20d
1   612	0360  E8 019A						     call memcpy
1   613
1   614	0363  33 C9						     xor  cx, cx	     ; i = 0
1   615
1   616	0365  8A 36 0343r					     mov  dh, BoxData[W_Num]
1   617	0369  8A 16 0344r					     mov  dl, BoxData[H_Num]
1   618
1   619	036D  C6 06 0343r 03					     mov  BoxData[W_Num], 3d
1   620	0372  C6 06 0344r 03					     mov  BoxData[H_Num], 3d
1   621
1   622	0377  50						     push ax		     ; push (4)
1   623	0378  B8 0340r						     mov  ax, offset EmptyStr
1   624
1   625	037B  E8 FEF5						     __Next:		     call PrintBox
1   626
1   627	037E  38 36 0343r									     cmp byte ptr BoxData[W_Num], dh+
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 12
main.asm



    628				     ; if( CURR_WIDTH == WIDTH )
1   629	0382  74 04										     je	__NoIncW
1   630	0384  FE 06 0343r									     inc BoxData[W_Num]
1   631
1   632	0388											     __NoIncW:
1   633
1   634	0388  38 16 0344r									     cmp byte ptr BoxData[H_Num], dl+
    635				     ; if( CURR_HEIGHT == HEIGHT )
1   636	038C  74 04										     je	__NoIncH
1   637	038E  FE 06 0344r									     inc BoxData[H_Num]
1   638
1   639	0392											     __NoIncH:
1   640
1   641	0392  41										     inc cx			    +
    642				     ; i++
1   643
1   644	0393  83 F9 11										     cmp cx, 17d
1   645	0396  74 0D										     je	__End
1   646
1   647	0398  50										     push ax			    +
    648				     ; push (5)
1   649	0399  51										     push cx			    +
    650				     ; push (6)
1   651	039A  B4 86										     mov  ah, 86h
1   652	039C  B9 0001										     mov  cx, 1d
1   653	039F  CD 15										     int  15h
1   654	03A1  59										     pop  cx			    +
    655				     ; pop  (6)
1   656	03A2  58										     pop  ax			    +
    657				     ; pop  (5)
1   658
1   659	03A3  EB D6										     jmp __Next
1   660
1   661	03A5							     __End:
1   662	03A5  58						     pop ax		     ; pop  (4)
1   663
1   664	03A6  88 36 0343r					     mov BoxData[W_Num], dh
1   665	03AA  88 16 0344r					     mov BoxData[H_Num], dl
1   666
1   667	03AE  E8 FEC2						     call PrintBox
1   668
1   669	03B1  5A						     pop dx		     ; pop  (3)
1   670	03B2  59						     pop cx		     ; pop  (2)
1   671	03B3  5B						     pop bx		     ; pop  (1)
1   672
1   673	03B4  C3						     ret
1   674	03B5							     endp
1   675
1   676				     ;------------------------------------------------
1   677				     ;	     INPUT STR
1   678				     ;------------------------------------------------
1   679				     ; ENTRY:	     NONE
1   680				     ; EXIT:	     AX	= STR LEN
1   681				     ; DESTROYS:     AX
1   682				     ;------------------------------------------------
1   683
1   684	      =0064		     InputLen =	100
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 13
main.asm



1   685	03B5  64*(00)		     InputStr db     InputLen dup (0)
1   686
1   687	0419			     Input		     proc
1   688
1   689	0419  52						     push dx		     ; push (1)
1   690	041A  33 D2						     xor  dx, dx	     ; i = 0
1   691
1   692	041C  B4 01						     __Next:		     mov ah, 01h			    +
    693				     ; input char
1   694	041E  CD 21										     int 21h
1   695
1   696	0420  56										     push si			    +
    697				     ; push (2)
1   698
1   699	0421  33 F6										     xor si, si			    +
    700				     ; SI = 0
1   701
1   702	0423  BE 03B5r										     mov si, offset InputStr	    +
    703				     ; SI = InputStr + DX
1   704	0426  03 F2										     add si, dx
1   705
1   706	0428  88 04										     mov [si], al
1   707
1   708	042A  5E										     pop si			    +
    709				     ; pop  (2)
1   710
1   711	042B  3C 0D										     cmp al, 13d		    +
    712				     ; if( al == '\r' )
1   713	042D  74 06										     je	__End
1   714
1   715	042F  42										     inc dx			    +
    716				     ; i++
1   717	0430  83 FA 64										     cmp dx, InputLen		    +
    718				     ; if( i ==	InputLen )
1   719	0433  75 E7										     jne __Next
1   720
1   721	0435							     __End:
1   722
1   723	0435  8B C2						     mov ax, dx
1   724	0437  5A						     pop dx		     ; pop  (1)
1   725
1   726	0438  C3						     ret
1   727	0439							     endp
1   728
1   729				     ;------------------------------------------------
1   730
    731				     include	     CMD_HNDL.ASM    ; CMD line	handler
1   732
1   733				     ;------------------------------------------------
1   734				     ;	     DIVIDE CMD	LINE ARGS ( FROM 82h + CL )
1   735				     ;	 TO ARRAY ( BYTE PTR )
1   736				     ;------------------------------------------------
1   737				     ; ENTRY:	 BX = ARR ADDR ( ARGS )
1   738				     ;		 CL = CMD LINE OFFSET
1   739				     ;		 CH = AMOUNT OF	NUMBERS	TO HANDLE
1   740				     ; EXIT:	     AX	= NEW CMD LINE OFFSET
1   741				     ; DESTROYS:     AX
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 14
main.asm



1   742				     ;------------------------------------------------
1   743
1   744	0439			     CmdLineHndl     proc
1   745
1   746	0439  33 C0				     xor ax, ax	     ; AX = 0 (	num args counter = 0 )
1   747
1   748	043B  51				     push cx	     ; push (1)
1   749	043C  56				     push si	     ; push (2)
1   750
1   751	043D  51				     push cx	     ; push (3)
1   752	043E  32 ED				     xor  ch, ch     ; CH = 0
1   753	0440  BE 0082				     mov  si, 82h    ; CurrSymPos = 82h	+ offset
1   754	0443  03 F1				     add  si, cx
1   755	0445  59				     pop  cx	     ; pop  (3)
1   756
1   757	0446  80 FD 00				     cmp ch, 0	     ; if( CH =	0 )
1   758	0449  74 46				     je	__EndNum
1   759
1   760	044B  51				     __NextNum:		 push cx	 ; push	(4)
1   761	044C  33 C9							 xor  cx, cx	 ; i = 0
1   762
1   763	044E  80 3C 20							 __Next:	 cmp byte ptr [si], ' '	     ; if( CurrSym  +
    764				     ==	' ' )
1   765	0451  74 13									 je __End
1   766	0453  80 3C 09									 cmp byte ptr [si], 9d	     ; if( CurrSym  +
    767				     ==	'\t' )
1   768	0456  74 0E									 je __End
1   769	0458  80 3C 00									 cmp byte ptr [si], 0d	     ; if( CurrSym  +
    770				     ==	'\0' )
1   771	045B  74 09									 je __End
1   772	045D  80 3C 0D									 cmp byte ptr [si], 13d	     ; if( CurrSym  +
    773				     ==	'\r' )
1   774	0460  74 04									 je __End
1   775
1   776
1   777	0462  41									 inc cx			     ; i++
1   778	0463  46									 inc si			     ; CurrSymPos++
1   779
1   780	0464  EB E8									 jmp __Next
1   781	0466								 __End:
1   782
1   783	0466  83 F9 00							 cmp cx, 0	 ; if( i == 0 )
1   784	0469  74 14							 je __EndArgsCheck
1   785
1   786									 ; STR to NUM
1   787	046B  53							 push bx	 ; push	(5)
1   788	046C  50							 push ax	 ; push	(6)
1   789	046D  8B DE							 mov  bx, si	 ; BX =	SI - i
1   790	046F  2B D9							 sub  bx, cx
1   791	0471  E8 0103							 call Atoi
1   792	0474  8B C8							 mov  cx, ax	 ; CX =	AX
1   793	0476  58							 pop  ax	 ; pop	(6)
1   794	0477  5B							 pop  bx	 ; pop	(5)
1   795
1   796									 ; put NUM to ARR
1   797	0478  53							 push bx		     ; push (7)
1   798	0479  03 D8							 add  bx, ax		     ; BX += CurrNumArg
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 15
main.asm



1   799	047B  88 0F							 mov  byte ptr [bx], cl	     ; arr[AX] = NUM
1   800	047D  5B							 pop  bx		     ; pop  (7)
1   801
1   802	047E  40							 inc ax			     ; NumArgs++
1   803
1   804	047F								 __EndArgsCheck:
1   805
1   806	047F  59							 pop cx			     ; pop (4)
1   807
1   808	0480  3A C5							 cmp al, ch		     ; if( AL == CH )
1   809	0482  74 0D							 je __EndNum
1   810
1   811	0484  80 3C 0D							 cmp byte ptr [si], 13d	     ; if( CurrSym == '\r' )
1   812	0487  74 08							 je __EndNum
1   813	0489  80 3C 00							 cmp byte ptr [si], 0d	     ; if( CurrSym == '\0' )
1   814	048C  74 03							 je __EndNum
1   815
1   816	048E  46							 inc si			     ; CurrSymPos++
1   817
1   818	048F  EB BA							 jmp __NextNum
1   819	0491					     __EndNum:
1   820
1   821	0491  8B C6				     mov ax, si	     ; AX = SI - 82h
1   822	0493  2D 0082				     sub ax, 82h
1   823
1   824	0496  5E				     pop si	     ; pop  (2)
1   825	0497  59				     pop cx	     ; pop  (1)
1   826
1   827	0498  C3				     ret
1   828	0499					     endp
1   829
1   830				     ;------------------------------------------------
    831				     include	     STR_HNDL.ASM    ; Str handler
1   832
1   833				     ;------------------------------------------------
1   834				     ;	     GET STR LEN
1   835				     ;------------------------------------------------
1   836				     ; ENTRY:	     BX	= STR ADDR
1   837				     ; EXIT:	     AX	= LEN
1   838				     ; EXPECTS:	 END SYM '$' ||	'\0' ||	'\r'
1   839				     ; DESTROYS: AX
1   840				     ;------------------------------------------------
1   841
1   842	0499			     StrLen	     proc
1   843
1   844	0499  33 C0				     xor ax, ax	     ; i = 0
1   845
1   846	049B  51						     push cx		     ; push (1)
1   847	049C  56						     push si		     ; push (2)
1   848
1   849	049D  8B F3				     __Next:		     mov  si, bx     ; SI = BX + i
1   850	049F  03 F0										 add  si, ax
1   851
1   852	04A1  40										     inc  ax		     ; i++
1   853	04A2  8B 0C										     mov  cx, [si]   ; CX = current +
    854				     symbol
1   855
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 16
main.asm



1   856	04A4  80 FD 24										     cmp  ch, '$'    ; if( ch == '$'+
    857				     )
1   858	04A7  74 0C										     je	__End
1   859	04A9  80 FD 00										     cmp  ch, 0d     ; if( ch ==    +
    860				     '\0' )
1   861	04AC  74 07										     je	__End
1   862	04AE  80 FD 0D										     cmp  ch, 13d    ; if( ch ==    +
    863				     '\r' )
1   864	04B1  74 02										     je	__End
1   865
1   866	04B3  EB E8										     jmp __Next
1   867
1   868	04B5							     __End:
1   869	04B5  5E						     pop si		     ; pop  (2)
1   870	04B6  59						     pop cx		     ; pop  (1)
1   871
1   872	04B7  C3				     ret
1   873	04B8					     endp
1   874
1   875				     ;------------------------------------------------
1   876				     ;	     GET ADDR OF CHR IN	ARR
1   877				     ;	     RET NULL IF NOT FOUND
1   878				     ;------------------------------------------------
1   879				     ; ENTRY:	     BX	= ARR ADDR
1   880				     ;			     CL	= CHR
1   881				     ;			     DX	= LEN OF THE COMPARED PART (IN BYTES)
1   882				     ; EXIT:	     AX	= ADDR OF CHR
1   883				     ; DESTROYS: AX
1   884				     ;------------------------------------------------
1   885
1   886	04B8			     MemChr		     proc
1   887
1   888	04B8  56						     push si		     ; push (1)
1   889
1   890	04B9  33 C0						     xor ax, ax		     ; AX = NULL
1   891	04BB  33 F6						     xor si, si		     ; i  = 0
1   892
1   893	04BD  83 FA 00						     cmp dx, 0d		     ; if( len == 0 )
1   894	04C0  74 0F						     je	__End
1   895
1   896	04C2  38 08						     __Next:		     cmp bx[si], cl	     ; if( Addr[i]  +
    897				     ==	CHR )
1   898	04C4  74 07										     je	__Found
1   899
1   900	04C6  46										     inc si
1   901
1   902	04C7  3B F2										     cmp si, dx
1   903	04C9  74 06										     je	__End
1   904
1   905	04CB  EB F5										     jmp __Next
1   906
1   907	04CD  8B C3						     __Found:		     mov ax, bx			     ; AX = +
    908				     ArrAddr + i
1   909	04CF  03 C6										     add ax, si
1   910
1   911	04D1							     __End:
1   912	04D1  5E						     pop si		     ; pop  (1)
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 17
main.asm



1   913
1   914	04D2  C3						     ret
1   915	04D3							     endp
1   916
1   917				     ;------------------------------------------------
1   918				     ;	     GET ADDR OF CHR IN	STR
1   919				     ;	     RET NULL IF NOT FOUND
1   920				     ;------------------------------------------------
1   921				     ; ENTRY:	     BX	= ARR ADDR
1   922				     ;			     CL	= CHR
1   923				     ; EXIT:	     AX	= ADDR OF CHR
1   924				     ; DESTROYS: AX
1   925				     ;------------------------------------------------
1   926
1   927	04D3			     StrChr		     proc
1   928
1   929	04D3  56						     push si		     ; push (1)
1   930
1   931	04D4  33 C0						     xor ax, ax		     ; AX = NULL
1   932	04D6  33 F6						     xor si, si		     ; i  = 0
1   933
1   934	04D8  38 08						     __Next:		     cmp byte ptr bx[si], cl	     ; if(  +
    935				     Addr[i] ==	CHR )
1   936	04DA  74 08										     je	__Found
1   937	04DC  80 38 00										     cmp byte ptr bx[si], 0d	    +
    938				     ; if( Addr[i] == 0	)
1   939	04DF  74 07										     je	__End
1   940
1   941	04E1  46										     inc si
1   942
1   943	04E2  EB F4										     jmp __Next
1   944
1   945	04E4  8B C3						     __Found:		     mov ax, bx				    +
    946				     ; AX = ArrAddr + i
1   947	04E6  03 C6										     add ax, si
1   948
1   949	04E8							     __End:
1   950	04E8  5E						     pop si		     ; pop  (1)
1   951
1   952	04E9  C3						     ret
1   953	04EA							     endp
1   954
1   955				     ;------------------------------------------------
1   956				     ;	     THE MEMSET	FUNCTION FILLS
1   957				     ;	     THE FIRST N BYTES OF THE MEMORY
1   958				     ;	     LOCATION POINTED TO BY THE
1   959				     ;	     DESTINATION ARGUMENT WITH THE
1   960				     ;	     CHARACTER SPECIFIED BY THE	CHR ARGUMENT
1   961				     ;------------------------------------------------
1   962				     ; ENTRY:	     BX	= DESTINATION
1   963				     ;			     CL	= CHR
1   964				     ;			     DX	= N
1   965				     ; EXIT:	     NONE
1   966				     ; DESTROYS: NONE
1   967				     ;------------------------------------------------
1   968
1   969	04EA			     MemSet		     proc
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 18
main.asm



1   970
1   971	04EA  56						     push si		     ; push (1)
1   972
1   973	04EB  33 F6						     xor si, si		     ; i = 0
1   974
1   975	04ED  83 FA 00						     cmp dx, 0d		     ; if( N ==	0 )
1   976	04F0  74 09						     je	__End
1   977
1   978	04F2  88 08						     __Next:		     mov byte ptr bx[si], cl	     ; BX[i]+
    979				     = CHR
1   980
1   981	04F4  46										     inc si			    +
    982				     ; i++
1   983
1   984	04F5  3B F2										     cmp si, dx			    +
    985				     ; if( i ==	N )
1   986	04F7  74 02										     je	__End
1   987
1   988	04F9  EB F7										     jmp __Next
1   989	04FB							     __End:
1   990	04FB  5E						     pop     si			     ; pop  (1)
1   991
1   992	04FC  C3						     ret
1   993	04FD							     endp
1   994
1   995				     ;------------------------------------------------
1   996				     ;	     THE MEMCPY	FUNCTION COPIES	N BYTES
1   997				     ;	     FROM THE ARRAY (SOURCE) TO	THE ARRAY
1   998				     ;	     (DESTINATION). IF THE ARRAYS OVERLAP,
1   999				     ;	     THE RESULT	OF THE COPY WILL BE UNDEFINED
1  1000				     ;------------------------------------------------
1  1001				     ; ENTRY:	     BX	= DESTINATION
1  1002				     ;			     CX	= SOURCE
1  1003				     ;			     DX	= N
1  1004				     ; EXIT:	     NONE
1  1005				     ; DESTROYS: NONE
1  1006				     ;------------------------------------------------
1  1007
1  1008	04FD			     MemCpy		     proc
1  1009
1  1010	04FD  56						     push si		     ; push (1)
1  1011	04FE  55						     push bp		     ; push (2)
1  1012
1  1013	04FF  8B E9						     mov bp, cx		     ; BP = CX
1  1014
1  1015	0501  33 F6						     xor si, si		     ; i = 0
1  1016
1  1017	0503  83 FA 00						     cmp dx, 0		     ; if( N ==	0 )
1  1018	0506  74 0D						     je	__End
1  1019
1  1020	0508  52						     __Next:		     push dx				    +
   1021				     ; push (3)
1  1022	0509  8A 12										     mov  dl, bp[si]
1  1023	050B  88 10										     mov  byte ptr bx[si], dl	    +
   1024				     ; BX[i] = CX[i]
1  1025	050D  5A										     pop  dx			    +
   1026				     ; pop  (3)
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 19
main.asm



1  1027
1  1028	050E  46										     inc si			    +
   1029				     ; i++
1  1030
1  1031	050F  3B F2										     cmp si, dx			    +
   1032				     ; if( N ==	i )
1  1033	0511  74 02										     je	__End
1  1034
1  1035	0513  EB F3										     jmp __Next
1  1036
1  1037	0515							     __End:
1  1038	0515  5D						     pop bp		     ; pop  (2)
1  1039	0516  5E						     pop si		     ; pop  (1)
1  1040
1  1041	0517  C3						     ret
1  1042	0518							     endp
1  1043
1  1044				     ;------------------------------------------------
1  1045				     ;	     THE STRCPY	FUNCTION COPIES	THE DATA FROM
1  1046				     ;	     THE SOURCE	ARGUMENT TO THE	DESTINATION
1  1047				     ;	     UNTIL THE END-OF-LINE( NULL ) CHARACTER
1  1048				     ;	     IS	ENCOUNTERED.
1  1049				     ;	     COPYING IS	DONE ALONG WITH	THE
1  1050				     ;	     END-OF-LINE CHARACTER
1  1051				     ;------------------------------------------------
1  1052				     ; ENTRY:	     BX	= DESTINATION
1  1053				     ;			     CX	= SOURCE
1  1054				     ; EXIT:	     NONE
1  1055				     ; DESTROYS: NONE
1  1056				     ;------------------------------------------------
1  1057
1  1058	0518			     StrCpy		     proc
1  1059
1  1060	0518  52						     push dx		     ; push (1)
1  1061	0519  56						     push si		     ; push (2)
1  1062	051A  55						     push bp		     ; push (3)
1  1063
1  1064	051B  8B E9						     mov bp, cx		     ; BP = CX
1  1065
1  1066	051D  33 F6						     xor si, si		     ; i = 0
1  1067
1  1068	051F  8A 12						     __Next:		     mov dl, bp[si]
1  1069	0521  88 10										     mov byte ptr bx[si], dl	    +
   1070				     ; BX[i] = CX[i]
1  1071
1  1072	0523  80 3A 00										     cmp byte ptr bp[si], 0d	    +
   1073				     ; if( CX[i] == 0 )
1  1074	0526  74 03										     je	__End
1  1075
1  1076	0528  46										     inc si			    +
   1077				     ; i++
1  1078
1  1079	0529  EB F4										     jmp __Next
1  1080
1  1081	052B							     __End:
1  1082	052B  5D						     pop bp		     ; pop  (3)
1  1083	052C  5E						     pop si		     ; pop  (2)
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 20
main.asm



1  1084	052D  5A						     pop dx		     ; pop  (1)
1  1085
1  1086	052E  C3						     ret
1  1087	052F							     endp
1  1088
1  1089				     ;------------------------------------------------
1  1090				     ;	     THE MEMCMP	FUNCTION COMPARES, BYTE	BY BYTE,
1  1091				     ;	     THE TWO ARRAYS ARR_1 AND ARR_2.
1  1092				     ;	     THE COMPARISON CONTINUES UNTIL N BYTES
1  1093				     ;	     HAVE BEEN CHECKED OR UNTIL	DIFFERENT
1  1094				     ;	     BYTES ARE ENCOUNTERED.
1  1095				     ;------------------------------------------------
1  1096				     ; ENTRY:	     BX	= ARR_1
1  1097				     ;			     CX	= ARR_2
1  1098				     ;			     DX	= N
1  1099				     ; EXIT:	     AX	= 0 ( ARR_1[i] == ARR_2[i] : FOR i in [0; N-1] )
1  1100				     ;			     AX	> 0 ( ARR_1[i] >  ARR_2[i] )
1  1101				     ;			     AX	< 0 ( ARR_1[i] <  ARR_2[i] )
1  1102				     ; DESTROYS: AX
1  1103				     ;------------------------------------------------
1  1104
1  1105	052F			     MemCmp		     proc
1  1106
1  1107	052F  56						     push si		     ; push (1)
1  1108	0530  55						     push bp		     ; push (2)
1  1109
1  1110	0531  8B E9						     mov bp, cx		     ; BP = CX
1  1111
1  1112	0533  33 F6						     xor si, si		     ; i  = 0
1  1113
1  1114	0535  83 FA 00						     cmp dx, 0d		     ; if( N ==	0 )
1  1115	0538  74 18						     je	__End
1  1116
1  1117	053A  33 C0						     __Next:		     xor  ax, ax			    +
   1118				     ; AX  = 0
1  1119	053C  8A 00										     mov  al, bx[si]		    +
   1120				     ; AL  = BX[i]
1  1121	053E  52										     push dx			    +
   1122				     ; push (3)
1  1123	053F  33 D2										     xor  dx, dx		    +
   1124				     ; DX = 0
1  1125	0541  8A 12										     mov  dl, bp[si]
1  1126	0543  2B C2										     sub  ax, dx		    +
   1127				     ; AX -= CX[i]
1  1128	0545  5A										     pop  dx			    +
   1129				     ; pop  (3)
1  1130
1  1131	0546  3D 0000										     cmp ax, 0d			    +
   1132				     ; if( AX != 0 )
1  1133	0549  75 07										     jne __End
1  1134
1  1135	054B  46										     inc si
1  1136
1  1137	054C  3B F2										     cmp si, dx			    +
   1138				     ; if( i ==	N )
1  1139	054E  74 02										     je	__End
1  1140
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 21
main.asm



1  1141	0550  EB E8										     jmp __Next
1  1142	0552							     __End:
1  1143	0552  5D						     pop bp		     ; pop  (2)
1  1144	0553  5E						     pop si		     ; pop  (1)
1  1145
1  1146	0554  C3						     ret
1  1147	0555							     endp
1  1148
1  1149				     ;------------------------------------------------
1  1150				     ;	     THE MEMCMP	FUNCTION COMPARES, BYTE	BY BYTE,
1  1151				     ;	     THE TWO STRINGS STR_1 AND STR_2.
1  1152				     ;	     THE COMPARISON CONTINUES UNTIL THE
1  1153				     ;	     END-OF-LINE( NULL ) OR UNTIL DIFFERENT
1  1154				     ;	     BYTES ARE ENCOUNTERED.
1  1155				     ;------------------------------------------------
1  1156				     ; ENTRY:	     BX	= STR_1
1  1157				     ;			     CX	= STR_2
1  1158				     ; EXIT:	     AX	= 0 ( STR_1[i] == STR_2[i] : FOR ALL i )
1  1159				     ;			     AX	> 0 ( STR_1[i] >  STR_2[i] )
1  1160				     ;			     AX	< 0 ( STR_1[i] <  STR_2[i] )
1  1161				     ; DESTROYS: AX
1  1162				     ;------------------------------------------------
1  1163
1  1164	0555			     StrCmp		     proc
1  1165
1  1166	0555  56						     push si		     ; push (1)
1  1167	0556  55						     push bp		     ; push (2)
1  1168
1  1169	0557  8B E9						     mov bp, cx		     ; BP = CX
1  1170
1  1171	0559  33 F6						     xor si, si		     ; i  = 0
1  1172
1  1173	055B  33 C0						     __Next:		     xor  ax, ax			    +
   1174				     ; AX  = 0
1  1175	055D  8A 00										     mov  al, bx[si]		    +
   1176				     ; AL  = BX[i]
1  1177	055F  52										     push dx			    +
   1178				     ; push (3)
1  1179	0560  33 D2										     xor  dx, dx		    +
   1180				     ; DX = 0
1  1181	0562  8A 12										     mov  dl, bp[si]
1  1182	0564  2B C2										     sub  ax, dx		    +
   1183				     ; AX -= CX[i]
1  1184	0566  5A										     pop  dx			    +
   1185				     ; pop  (3)
1  1186
1  1187	0567  3D 0000										     cmp ax, 0d			    +
   1188				     ; if( AX != 0 )
1  1189	056A  75 08										     jne __End
1  1190
1  1191	056C  80 38 00										     cmp byte ptr bx[si], 0d	    +
   1192				     ; if( BX[i] == 0 )
1  1193	056F  74 03										     je	__End
1  1194
1  1195	0571  46										     inc si
1  1196
1  1197	0572  EB E7										     jmp __Next
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 22
main.asm



1  1198	0574							     __End:
1  1199	0574  5D						     pop bp		     ; pop  (2)
1  1200	0575  5E						     pop si		     ; pop  (1)
1  1201
1  1202	0576  C3						     ret
1  1203	0577							     endp
1  1204
1  1205				     ;------------------------------------------------
1  1206				     ;	     TRANSLATE STR TO NUMBER
1  1207				     ;------------------------------------------------
1  1208				     ; ENTRY:	     BX	= STR ADDR
1  1209				     ; EXIT:	     AX	= NUM
1  1210				     ; EXPECTS:	     CX	= STR LEN
1  1211				     ; DESTROYS:     AX
1  1212				     ;------------------------------------------------
1  1213
1  1214	0577			     Atoi		     proc
1  1215
1  1216	0577  33 C0						     xor ax, ax		     ; AX = 0
1  1217
1  1218	0579  52						     push dx		     ; push (1)
1  1219	057A  56						     push si		     ; push (2)
1  1220
1  1221	057B  33 D2						     xor dx, dx		     ; i = 0
1  1222
1  1223	057D  8B F3						     __Next:		     mov si, bx		     ; SI = BX +    +
   1224				     STR_LEN - i
1  1225	057F  03 F1										     add si, cx
1  1226	0581  2B F2										     sub si, dx
1  1227	0583  83 EE 01										     sub si, 1
1  1228
1  1229	0586  51										     push cx		     ; push +
   1230				     (3)
1  1231
1  1232	0587  50										     push ax		     ; push +
   1233				     (4)
1  1234	0588  33 C0										     xor  ax, ax     ; AX = 0
1  1235	058A  8A 04										     mov  al, [si]   ; AX = [SI] -  +
   1236				     '0'
1  1237	058C  2C 30										     sub  al, 48d
1  1238
1  1239	058E  52										     push dx		     ; push +
   1240				     (5)
1  1241	058F  8B CA										     mov  cx, dx	     ; AX = +
   1242				     AX	* 10^DX
1  1243	0591  BE 000A										     mov  si, 10d
1  1244	0594  E3 08										     jcxz __NoMul
1  1245
1  1246	0596  F7 E6										     __Mul:		     mul si
1  1247
1  1248	0598  49														    +
   1249				     dec cx
1  1250	0599  83 F9 00														    +
   1251				     cmp cx, 0
1  1252	059C  75 F8														    +
   1253				     jne __Mul
1  1254
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 23
main.asm



1  1255	059E											     __NoMul:
1  1256	059E  5A										     pop  dx		     ; pop  +
   1257				     (5)
1  1258	059F  8B C8										     mov  cx, ax
1  1259
1  1260	05A1  58										     pop ax		     ; pop  +
   1261				     (4)
1  1262	05A2  03 C1										     add ax, cx
1  1263	05A4  59										     pop cx		     ; pop  +
   1264				     (3)
1  1265
1  1266	05A5  42										     inc dx		     ; i++
1  1267
1  1268	05A6  3B D1										     cmp dx, cx		     ; if( i+
   1269				     ==	CX )
1  1270	05A8  75 D3										     jne __Next
1  1271
1  1272	05AA  5E						     pop si		     ; pop  (2)
1  1273	05AB  5A						     pop dx		     ; pop  (1)
1  1274
1  1275	05AC  C3						     ret
1  1276	05AD							     endp
1  1277
1  1278				     ;------------------------------------------------
   1279				     include	     NUM_CNVR.ASM    ; Print AX	in BIN/DEC/HEX
1  1280
1  1281				     ;------------------------------------------------
1  1282				     ;	     PRINT AX IN BIN
1  1283				     ;------------------------------------------------
1  1284				     ; ENTRY:	     AX	= NUM
1  1285				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1  1286				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1  1287				     ; EXIT:	     NONE
1  1288				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1  1289				     ; DESTROYS:     NONE
1  1290				     ;------------------------------------------------
1  1291
1  1292	      =0010		     bin_len = 16d						     ; len of bin str
1  1293
1  1294	05AD			     PrintBin		     proc
1  1295
1  1296	05AD  57						     push di				     ; push (0)
1  1297
1  1298	05AE  50						     push ax				     ; push (1)
1  1299
1  1300	05AF  E8 FBD7						     call GetVideoPos		     ; AX = Video position from	(X; +
   1301				     Y)
1  1302	05B2  BF 0020						     mov di, bin_len * 2d    ; i = bin_len * 2 + AX
1  1303	05B5  03 F8						     add di, ax
1  1304	05B7  FD						     std
1  1305
1  1306	05B8  58						     pop  ax				     ; pop  (1)
1  1307
1  1308	05B9  50 52						     push ax dx				     ; push (2)	(3)
1  1309
1  1310	05BB  33 D2						     xor  dx, dx			     ; i = 0
1  1311
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 24
main.asm



1  1312	05BD  D1 E8						     __Next:		     shr ax, 1				    +
   1313				     ; AX /= 2
1  1314
1  1315	05BF  50										     push ax			    +
   1316				     ; push (4)
1  1317
1  1318	05C0  72 05										     jc	__One
1  1319
1  1320	05C2  B0 30										     __Zero:		     mov al,+
   1321				     '0'		     ; '0'
1  1322	05C4  EB 03 90														    +
   1323				     jmp __End
1  1324
1  1325	05C7  B0 31										     __One:		     mov al,+
   1326				     '1'		     ; '1'
1  1327
1  1328	05C9  B4 70						     __End:		     mov ah, 70h			    +
   1329				     ; black on	white
1  1330
1  1331	05CB  83 EF 02										     sub di, 2			    +
   1332				     ; print( ax ) // with 1 sym left( 2 bytes )
1  1333	05CE  AB										     stosw
1  1334	05CF  83 C7 02										     add di, 2
1  1335
1  1336	05D2  58										     pop ax			    +
   1337				     ; pop (4)
1  1338
1  1339	05D3  42										     inc dx
1  1340
1  1341	05D4  83 FA 10										     cmp dx, bin_len		    +
   1342				     ; if( dx == bin_len )
1  1343	05D7  75 E4										     jne __Next
1  1344
1  1345	05D9  5A 58						     pop dx ax			     ; pop  (3)	(2)
1  1346	05DB  5F						     pop di			     ; pop  (0)
1  1347
1  1348	05DC  C3						     ret
1  1349	05DD							     endp
1  1350
1  1351				     ;------------------------------------------------
1  1352				     ;	     PRINT AX IN HEX
1  1353				     ;------------------------------------------------
1  1354				     ; ENTRY:	     AX	= NUM
1  1355				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1  1356				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1  1357				     ; EXIT:	     NONE
1  1358				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1  1359				     ; DESTROYS:     NONE
1  1360				     ;------------------------------------------------
1  1361
1  1362	      =0010		     hex_len = 16d						     ; len of hex str
1  1363
1  1364	05DD			     PrintHex		     proc
1  1365
1  1366	05DD  57						     push di				     ; push (0)
1  1367
1  1368	05DE  50						     push ax				     ; push (1)
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 25
main.asm



1  1369
1  1370	05DF  E8 FBA7						     call GetVideoPos		     ; AX = Video position from	(X; +
   1371				     Y)
1  1372	05E2  BF 0020						     mov di, hex_len * 2d    ; i = hex_len * 2 + AX
1  1373	05E5  03 F8						     add di, ax
1  1374	05E7  FD						     std
1  1375
1  1376	05E8  58						     pop  ax				     ; pop  (1)
1  1377
1  1378	05E9  50 51 52						     push ax cx	dx		     ; push (2)	(3) (4)
1  1379
1  1380	05EC  33 D2						     xor dx, dx				     ; i = 0
1  1381
1  1382	05EE  B9 0000						     __Next:		     mov cx, 0			     ;	    +
   1383				     shifts counter
1  1384
1  1385	05F1  52										     push dx			    +
   1386				     ; push (5)
1  1387	05F2  BA 0000										     mov  dx, 0			    +
   1388				     ; DX = 0
1  1389
1  1390	05F5  D1 E8										     __Shift:		     shr ax,+
   1391				     1		     ; AX /= 2
1  1392
1  1393	05F7  73 09														    +
   1394				     jnc __End
1  1395
1  1396	05F9  50														    +
   1397				     __One:		     push ax		     ; push (6)
1  1398	05FA  B8 0001														    +
   1399				     mov  ax, 1		     ; AX = 0001b
1  1400	05FD  D3 E0														    +
   1401				     shl  ax, cl	     ; DX += 2^CX
1  1402	05FF  03 D0														    +
   1403				     add  dx, ax
1  1404	0601  58														    +
   1405				     pop      ax		     ; pop  (6)
1  1406
1  1407	0602  41										     __End:		     inc cx +
   1408				     ; shifts counter ++
1  1409	0603  83 F9 04														    +
   1410				     cmp cx, 4d		     ; if( numShifts ==	4 )
1  1411	0606  75 ED														    +
   1412				     jne __Shift
1  1413
1  1414	0608  8B C8										     mov cx, ax			    +
   1415				     ; CX = AX
1  1416
1  1417	060A  83 FA 0A										     cmp dx, 10d		    +
   1418				     ; if( DX >= 10 )
1  1419	060D  7D 08										     jge __Sym
1  1420
1  1421	060F  83 C2 30										     __Digit:		     add dx,+
   1422				     48d	     ; print( DX + '0' )
1  1423	0612  8A C2														    +
   1424				     mov al, dl
1  1425	0614  EB 09 90														    +
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 26
main.asm



   1426				     jmp __Print
1  1427
1  1428	0617  83 EA 0A										     __Sym:		     sub dx,+
   1429				     10		     ; print( DX - 10 +	'A' )
1  1430	061A  83 C2 41														    +
   1431				     add dx, 65d
1  1432	061D  8A C2														    +
   1433				     mov al, dl
1  1434
1  1435	061F  5A						     __Print:		     pop dx			     ; pop  +
   1436				     (5)
1  1437
1  1438	0620  B4 70										     mov ah, 70h		    +
   1439				     ; black on	white
1  1440
1  1441	0622  83 EF 02										     sub di, 2			    +
   1442				     ; print( ax ) // with 1 sym left( 2 bytes )
1  1443	0625  AB										     stosw
1  1444	0626  83 C7 02										     add di, 2
1  1445
1  1446	0629  8B C1										     mov ax, cx			    +
   1447				     ; AX = CX
1  1448
1  1449	062B  42										     inc dx			    +
   1450				     ; i++
1  1451
1  1452	062C  83 FA 10										     cmp dx, hex_len	     ; if(  +
   1453				     dx	== hex_len )
1  1454	062F  75 BD										     jne __Next
1  1455
1  1456	0631  5A 59 58						     pop dx cx ax		     ; pop  (4)	(3) (2)
1  1457	0634  5F						     pop di				     ; pop  (0)
1  1458
1  1459	0635  C3						     ret
1  1460	0636							     endp
1  1461
1  1462				     ;------------------------------------------------
1  1463				     ;	     PRINT AX IN DEC
1  1464				     ;------------------------------------------------
1  1465				     ; ENTRY:	     AX	= NUM
1  1466				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1  1467				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1  1468				     ; EXIT:	     NONE
1  1469				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1  1470				     ; DESTROYS:     NONE
1  1471				     ;------------------------------------------------
1  1472
1  1473	      =0005		     dec_len = 5d
1  1474
1  1475	0636			     PrintDec		     proc
1  1476
1  1477	0636  57						     push di				     ; pop  (0)
1  1478
1  1479	0637  50						     push ax				     ; push (1)
1  1480
1  1481	0638  E8 FB4E						     call GetVideoPos		     ; AX = Video position from	(X; +
   1482				     Y)
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 27
main.asm



1  1483	063B  BF 000A						     mov di, dec_len * 2d    ; i = dec_len * 2 + AX
1  1484	063E  03 F8						     add di, ax
1  1485	0640  FD						     std
1  1486
1  1487	0641  58						     pop  ax				     ; pop  (1)
1  1488
1  1489	0642  50 51 52						     push ax cx	dx		     ; push (2)	(3) (4)
1  1490
1  1491	0645  33 D2						     xor dx, dx				     ; i = 0
1  1492	0647  B9 000A						     mov cx, 10d			     ; CX = 10
1  1493
1  1494	064A  52						     __Next:		     push dx			     ; push +
   1495				     (5)
1  1496
1  1497	064B  33 D2										     xor dx, dx			    +
   1498				     ; DX = 0
1  1499
1  1500	064D  F7 F1										     div  cx			    +
   1501				     ; AX /= 10
1  1502
1  1503	064F  50										     push ax			    +
   1504				     ; push (6)
1  1505
1  1506	0650  80 C2 30										     add  dl, 48d	     ; print+
   1507				     ( DL + '0'	)
1  1508	0653  8A C2										     mov  al, dl
1  1509
1  1510	0655  B4 70										     mov  ah, 70h	     ; black+
   1511				     on	white
1  1512
1  1513	0657  83 EF 02										     sub di, 2			    +
   1514				     ; print( ax ) // with 1 sym left( 2 bytes )
1  1515	065A  AB										     stosw
1  1516	065B  83 C7 02										     add di, 2
1  1517
1  1518	065E  58										     pop ax			    +
   1519				     ; pop  (6)
1  1520	065F  5A										     pop dx			    +
   1521				     ; pop  (5)
1  1522
1  1523	0660  42										     inc dx
1  1524
1  1525	0661  83 FA 05										     cmp dx, dec_len	     ; if(  +
   1526				     DX	== dec_len )
1  1527	0664  75 E4										     jne __Next
1  1528
1  1529	0666  5A 59 58						     pop dx cx ax		     ; pop  (4)	(3) (2)
1  1530	0669  5F						     pop di				     ; pop  (0)
1  1531
1  1532	066A  C3						     ret
1  1533	066B							     endp
1  1534
1  1535				     ;------------------------------------------------
1  1536				     ;	     PRINT AX IN BIN/HEX/DEC
1  1537				     ;------------------------------------------------
1  1538				     ; ENTRY:	     AX	= NUM
1  1539				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 28
main.asm



1  1540				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1  1541				     ; EXIT:	     NONE
1  1542				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1  1543				     ; DESTROYS:     NONE
1  1544				     ;------------------------------------------------
1  1545
1  1546	066B			     PrintNum		     proc
1  1547
1  1548	066B  53						     push bx				     ; push (1)
1  1549
1  1550	066C  E8 FF3E						     call PrintBin
1  1551
1  1552	066F  80 C7 11						     add bh, bin_len + 1d    ; X
1  1553	0672  E8 FF68						     call PrintHex
1  1554
1  1555	0675  80 C7 11						     add bh, hex_len + 1d    ; X
1  1556	0678  E8 FFBB						     call PrintDec
1  1557
1  1558	067B  5B						     pop bx				     ; pop  (1)
1  1559
1  1560	067C  C3						     ret
1  1561	067D							     endp
1  1562
1  1563				     ;------------------------------------------------
   1564
   1565				     end		     Start
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 29
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "03/02/23"
??FILENAME			  Text	 "main	  "
??TIME				  Text	 "23:46:46"
??VERSION			  Number 040A
@32BIT				  Text	 0
@CODE				  Text	 DGROUP
@CODESIZE			  Text	 0
@CPU				  Text	 0103H
@CURSEG				  Text	 _TEXT
@DATA				  Text	 DGROUP
@DATASIZE			  Text	 0
@FILENAME			  Text	 MAIN
@INTERFACE			  Text	 000H
@MODEL				  Text	 1
@STACK				  Text	 DGROUP
@WORDSIZE			  Text	 2
ANIMBOX				  Near	 DGROUP:0355
ATOI				  Near	 DGROUP:0577
BIN_LEN				  Number 0010
BOXDATA				  Byte	 DGROUP:0341
CLRSCREEN			  Near	 DGROUP:017B
CLR_NUM				  Number 0004
CMDDATA				  Byte	 DGROUP:0139
CMDLINEHNDL			  Near	 DGROUP:0439
DEC_LEN				  Number 0005
EMPTYSTR			  Byte	 DGROUP:0340
FILLSCREEN			  Near	 DGROUP:014D
GETVIDEOPOS			  Near	 DGROUP:0189
HEX_LEN				  Number 0010
H_NUM				  Number 0003
INPUT				  Near	 DGROUP:0419
INPUTLEN			  Number 0064
INPUTSTR			  Byte	 DGROUP:03B5
MEMCHR				  Near	 DGROUP:04B8
MEMCMP				  Near	 DGROUP:052F
MEMCPY				  Near	 DGROUP:04FD
MEMSET				  Near	 DGROUP:04EA
PRINTBIN			  Near	 DGROUP:05AD
PRINTBOX			  Near	 DGROUP:0273
PRINTCHAR			  Near	 DGROUP:019B
PRINTDEC			  Near	 DGROUP:0636
PRINTHEX			  Near	 DGROUP:05DD
PRINTHRZLINE			  Near	 DGROUP:01CC
PRINTNUM			  Near	 DGROUP:066B
PRINTSTR			  Near	 DGROUP:01A6
PRINTVRTLINE			  Near	 DGROUP:0209
START				  Near	 DGROUP:0100
STRCHR				  Near	 DGROUP:04D3
STRCMP				  Near	 DGROUP:0555
STRCPY				  Near	 DGROUP:0518
STRLEN				  Near	 DGROUP:0499
TYPE_0				  Byte	 DGROUP:0246
TYPE_1				  Byte	 DGROUP:024F
TYPE_2				  Byte	 DGROUP:0258
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 30
Symbol Table



TYPE_3				  Byte	 DGROUP:0261
TYPE_4				  Byte	 DGROUP:026A
TYPE_NUM			  Number 0005
W_NUM				  Number 0002
X_NUM				  Number 0000
Y_NUM				  Number 0001
__DIGIT				  Near	 DGROUP:060F
__END				  Near	 DGROUP:0169
__END				  Near	 DGROUP:01C7
__END				  Near	 DGROUP:0208
__END				  Near	 DGROUP:0245
__END				  Near	 DGROUP:03A5
__END				  Near	 DGROUP:0435
__END				  Near	 DGROUP:0466
__END				  Near	 DGROUP:04B5
__END				  Near	 DGROUP:04D1
__END				  Near	 DGROUP:04E8
__END				  Near	 DGROUP:04FB
__END				  Near	 DGROUP:0515
__END				  Near	 DGROUP:052B
__END				  Near	 DGROUP:0552
__END				  Near	 DGROUP:0574
__END				  Near	 DGROUP:05C9
__END				  Near	 DGROUP:0602
__ENDARGSCHECK			  Near	 DGROUP:047F
__ENDNEXTLINE			  Near	 DGROUP:0177
__ENDNUM			  Near	 DGROUP:0491
__ENDPRINTING			  Near	 DGROUP:0204
__ENDPRINTING			  Near	 DGROUP:0241
__FOUND				  Near	 DGROUP:04CD
__FOUND				  Near	 DGROUP:04E4
__MUL				  Near	 DGROUP:0596
__NEXT				  Near	 DGROUP:015A
__NEXT				  Near	 DGROUP:01AC
__NEXT				  Near	 DGROUP:01F7
__NEXT				  Near	 DGROUP:0234
__NEXT				  Near	 DGROUP:037B
__NEXT				  Near	 DGROUP:041C
__NEXT				  Near	 DGROUP:044E
__NEXT				  Near	 DGROUP:049D
__NEXT				  Near	 DGROUP:04C2
__NEXT				  Near	 DGROUP:04D8
__NEXT				  Near	 DGROUP:04F2
__NEXT				  Near	 DGROUP:0508
__NEXT				  Near	 DGROUP:051F
__NEXT				  Near	 DGROUP:053A
__NEXT				  Near	 DGROUP:055B
__NEXT				  Near	 DGROUP:057D
__NEXT				  Near	 DGROUP:05BD
__NEXT				  Near	 DGROUP:05EE
__NEXT				  Near	 DGROUP:064A
__NEXTLINE			  Near	 DGROUP:0157
__NEXTNUM			  Near	 DGROUP:044B
__NOINCH			  Near	 DGROUP:0392
__NOINCW			  Near	 DGROUP:0388
__NOMUL				  Near	 DGROUP:059E
__NOTUSERTYPE			  Near	 DGROUP:0120
Turbo Assembler	 Version 4.1	    03/02/23 23:46:46	    Page 31
Symbol Table



__ONE				  Near	 DGROUP:05C7
__ONE				  Near	 DGROUP:05F9
__PRINT				  Near	 DGROUP:061F
__SHIFT				  Near	 DGROUP:05F5
__SYM				  Near	 DGROUP:0617
__ZERO				  Near	 DGROUP:05C2

Macro Name

EXIT

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  _DATA				  16  0000 Word	  Public  DATA
  _TEXT				  16  067D Word	  Public  CODE
